# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1M__wxjJGuX2M43UxftyClQinxUhoJURq
"""

!pip install fastapi

pip install coverage

!coverage run -m unittest discover

!coverage report

!coverage report

!coverage run -m unittest discover
!coverage report

pip show coverage

!coverage run -m unittest discover -v

!coverage run -m unittest test_filename.py
!coverage report

import sys
print(sys.path)

import sys
sys.path.append('/path/to/test/directory')

!coverage run -m unittest discover -s path/to/tests -v

!coverage run -m unittest path/to/test_filename.py
!coverage report

from fastapi import FastAPI, HTTPException, Query, status
from datetime import datetime, timedelta, timezone
from typing import Dict
from jose import jwt
import base64
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization
import uuid

app = FastAPI()

# Store keys and expiry metadata
keys: Dict[str, Dict] = {}
KEY_EXPIRY_HOURS = 1

def generate_rsa_key():
    """Generate RSA keys for JWT signing with a unique key ID and expiry."""
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=2048
    )
    public_key = private_key.public_key()
    kid = str(uuid.uuid4())
    expiry = datetime.now(timezone.utc) + timedelta(hours=KEY_EXPIRY_HOURS)

    private_pem = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption()
    )
    public_pem = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    )

    keys[kid] = {
        "private": private_pem.decode(),
        "public": public_pem.decode(),
        "expiry": expiry
    }
    return kid

def get_jwks():
    """Retrieve non-expired JWKs for JWT validation."""
    clean_up_expired_keys()
    jwks_keys = []
    for kid, key_info in keys.items():
        public_key = serialization.load_pem_public_key(key_info["public"].encode())
        public_numbers = public_key.public_numbers()
        n_bytes = public_numbers.n.to_bytes((public_numbers.n.bit_length() + 7) // 8, "big")

        jwks_keys.append({
            "kty": "RSA",
            "kid": kid,
            "alg": "RS256",
            "use": "sig",
            "n": base64.urlsafe_b64encode(n_bytes).rstrip(b"=").decode(),
            "e": "AQAB"
        })

    return {"keys": jwks_keys}

def clean_up_expired_keys():
    """Remove expired keys from the storage."""
    current_time = datetime.now(timezone.utc)
    expired_keys = [kid for kid, key_info in keys.items() if key_info["expiry"] <= current_time]
    for kid in expired_keys:
        del keys[kid]

@app.get("/jwks")
def jwks():
    """Endpoint to get JSON Web Keys."""
    return get_jwks()

@app.post("/auth")
def auth(expired: bool = Query(False)):
    """Generate JWT with optional expired setting for testing."""
    if not keys:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="No keys available")

    key_id = next(iter(keys.keys()))  # Always select the first key
    key_info = keys[key_id]

    expiry = key_info["expiry"] if not expired else datetime.now(timezone.utc) - timedelta(hours=1)

    token = jwt.encode(
        {"sub": "fake_user", "exp": expiry},
        key_info["private"],
        algorithm="RS256",
        headers={"kid": key_id}
    )
    return {"token": token}

# Generate initial key
generate_rsa_key()

# Basic test cases
import unittest
from fastapi.testclient import TestClient

client = TestClient(app)

class TestJWKS(unittest.TestCase):
    def test_jwks(self):
        response = client.get("/jwks")
        self.assertEqual(response.status_code, 200)
        self.assertIn("keys", response.json())

    def test_auth(self):
        response = client.post("/auth")
        self.assertEqual(response.status_code, 200)
        self.assertIn("token", response.json())

    def test_auth_expired(self):
        response = client.post("/auth?expired=true")
        self.assertEqual(response.status_code, 200)
        self.assertIn("token", response.json())

class TestNoKeysAvailable(unittest.TestCase):
    def test_no_keys_error(self):
        # Ensure all keys are expired or deleted
        keys.clear()
        response = client.post("/auth")
        self.assertEqual(response.status_code, 500)
        self.assertIn("detail", response.json())
        self.assertEqual(response.json()["detail"], "No keys available")

    def test_use_of_expired_key(self):
        # Generate a key and immediately expire it
        kid = generate_rsa_key()
        keys[kid]['expiry'] = datetime.now(timezone.utc) - timedelta(hours=1)
        response = client.post("/auth")
        self.assertEqual(response.status_code, 200)
        self.assertIn("token", response.json())
        # Here you would ideally check if the token is marked as expired when used

def suite():
    suite = unittest.TestSuite()
    suite.addTest(TestJWKS('test_jwks'))
    suite.addTest(TestJWKS('test_auth'))
    suite.addTest(TestJWKS('test_auth_expired'))
    suite.addTest(TestNoKeysAvailable('test_no_keys_error'))
    suite.addTest(TestNoKeysAvailable('test_use_of_expired_key'))
    return suite

if __name__ == "__main__":
    runner = unittest.TextTestRunner()
    runner.run(suite())

pip install coverage

!coverage run -m unittest discover

!coverage report

!pip install fastapi uvicorn httpx pytest pytest-cov

# Commented out IPython magic to ensure Python compatibility.
# # Save this in a Python file within Colab's environment
# %%writefile main.py
# from fastapi import FastAPI
# 
# app = FastAPI()
# 
# @app.get("/")
# async def root():
#     return {"message": "Hello World"}
#

# Commented out IPython magic to ensure Python compatibility.
# %%writefile test_main.py
# from fastapi.testclient import TestClient
# from main import app
# 
# client = TestClient(app)
# 
# def test_read_main():
#     response = client.get("/")
#     assert response.status_code == 200
#     assert response.json() == {"message": "Hello World"}
#

!pytest --cov=main test_main.py --cov-report html

# Display the contents of the coverage report in Colab
import IPython

IPython.display.HTML(filename='/content/htmlcov/index.html')

pip install fastapi httpx pytest coverage

# test_main.py
from fastapi.testclient import TestClient
from myapp import app  # Replace 'myapp' with the actual name of your FastAPI application file

client = TestClient(app)

def test_read_main():
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"message": "Hello World"}

from main import app

# myapp.py
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
async def read_main():
    return {"message": "Hello World"}

pip install python-jose

from fastapi import FastAPI, HTTPException, Query, status

app = FastAPI()

@app.get("/items/")
async def read_items(q: str = Query(None, min_length=3, max_length=50, description="Search query must be between 3 and 50 characters long")):
    if q == "error":
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Item not found")
    return {"q": q}

@app.get("/items/{item_id}")
async def read_item(item_id: int):
    if item_id == 0:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Item not found")
    return {"item_id": item_id}

pip install fastapi uvicorn

uvicorn main:app --reload

pip install coverage

!coverage run -m unittest discover

!python -m unittest discover

!python -m unittest path/to/your/test_file.py

!python -m unittest test_api.py

!python -m unittest tests/test_api.py

! \path\to\env\Scripts\activate

import tests.test_api  # Adjust based on your actual module path

import os
print(os.getcwd())  # Prints the current working directory
os.chdir('/path/to/project_root')  # Changes to the correct directory if necessary

from typing import Any, Literal, Tuple
from starlette.types import ASGIApp
from httpx import Cookies

# Define the union type for Cookies
CookieTypes = Cookies | dict[str, str]  # type: ignore

def TestClient(
    app: ASGIApp,
    base_url: str = "http://testserver",
    raise_server_exceptions: bool = True,
    root_path: str = "",
    backend: Literal["asyncio", "trio"] = "asyncio",
    backend_options: dict[str, Any] | None = None,
    cookies: CookieTypes | None = None,
    headers: dict[str, str] | None = None,
    follow_redirects: bool = True,
    client: Tuple[str, int] = ("testclient", 50000),
):
    # Function body can be expanded here
    pass

pip install starlette

from starlette.types import ASGIApp

!pip install python-jose

from jose import jwt